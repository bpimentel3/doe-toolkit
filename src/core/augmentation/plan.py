"""
Augmentation Plan Architecture.

This module defines the composable data structures for design augmentation,
enabling a clean separation between recommendation generation, plan selection,
and plan execution.
"""

from typing import Dict, List, Optional, Union, Literal, Any
from dataclasses import dataclass, field
import pandas as pd
import numpy as np
from abc import ABC, abstractmethod


_plan_counter = 0

def create_plan_id() -> str:
    """
    Generate unique plan ID.
    
    Returns
    -------
    str
        Unique ID (timestamp + counter)
    """
    global _plan_counter
    import time
    _plan_counter += 1
    return f"plan_{int(time.time() * 1000)}_{_plan_counter}"

@dataclass
class FoldoverConfig:
    """
    Configuration for foldover augmentation.
    
    Attributes
    ----------
    foldover_type : {'full', 'single_factor'}
        Type of foldover
    factor_to_fold : str, optional
        Factor to fold (for single-factor foldover)
    reason : str, optional
        Why this factor was chosen
    """
    foldover_type: Literal['full', 'single_factor']
    factor_to_fold: Optional[str] = None
    reason: Optional[str] = None


@dataclass
class OptimalAugmentConfig:
    """
    Configuration for optimal augmentation (D-optimal or I-optimal).
    
    Attributes
    ----------
    new_model_terms : List[str]
        Model terms to add (for model extension)
    n_runs_to_add : int
        Number of runs to add
    criterion : {'D', 'I'}, default='D'
        Optimality criterion:
        - 'D': D-optimal (maximize det(X'X), best for parameter estimates)
        - 'I': I-optimal (minimize avg prediction variance, best for prediction)
    prediction_grid_config : dict, optional
        Configuration for I-optimal prediction grid (ignored for D-optimal)
    """
    new_model_terms: List[str]
    n_runs_to_add: int
    criterion: Literal['D', 'I'] = 'D'
    prediction_grid_config: Optional[dict] = None


@dataclass
class ValidationResult:
    """
    Result of design validation.
    
    Attributes
    ----------
    is_valid : bool
        Whether design passes validation
    errors : List[str]
        Critical errors (prevent execution)
    warnings : List[str]
        Warnings (don't prevent execution)
    metrics : Dict[str, float]
        Validation metrics
    """
    is_valid: bool
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    metrics: Dict[str, float] = field(default_factory=dict)


@dataclass
class AugmentationPlan:
    """
    Executable plan for design augmentation.
    
    This is the central object that flows through the augmentation system:
    - Generated by recommendation engine
    - Selected by user (or auto-selected)
    - Executed to produce augmented design
    - Validated before and after execution
    
    Attributes
    ----------
    plan_id : str
        Unique identifier
    plan_name : str
        Human-readable name
    strategy : {'foldover', 'd_optimal', 'custom'}
        Augmentation strategy type
    strategy_config : Union[FoldoverConfig, OptimalAugmentConfig]
        Strategy-specific configuration
    original_design : pd.DataFrame
        Design being augmented
    factors : List[Factor]
        Factor definitions
    n_runs_to_add : int
        Number of new runs
    total_runs_after : int
        Total runs after augmentation
    expected_improvements : Dict[str, str]
        Expected quality improvements
    benefits_responses : List[str]
        Which responses benefit
    primary_beneficiary : str
        Response with most benefit
    experimental_cost : float
        Cost estimate (e.g., n_runs * cost_per_run)
    utility_score : float
        Overall utility (0-100)
    rank : int
        Rank among alternative plans (1=best)
    metadata : Dict[str, Any]
        Additional metadata (generators, model terms, etc.)
    
    Examples
    --------
    >>> from src.core.factors import Factor, FactorType, ChangeabilityLevel
    >>> 
    >>> factors = [
    ...     Factor("A", FactorType.CONTINUOUS, ChangeabilityLevel.EASY, [-1, 1]),
    ...     Factor("B", FactorType.CONTINUOUS, ChangeabilityLevel.EASY, [-1, 1])
    ... ]
    >>> 
    >>> config = FoldoverConfig(foldover_type='full')
    >>> 
    >>> plan = AugmentationPlan(
    ...     plan_id='plan_1',
    ...     plan_name='Full Foldover',
    ...     strategy='foldover',
    ...     strategy_config=config,
    ...     original_design=design,
    ...     factors=factors,
    ...     n_runs_to_add=8,
    ...     total_runs_after=16,
    ...     expected_improvements={'resolution': '3 â†’ 4'},
    ...     benefits_responses=['Yield'],
    ...     primary_beneficiary='Yield',
    ...     experimental_cost=8.0,
    ...     utility_score=92.0,
    ...     rank=1,
    ...     metadata={}
    ... )
    """
    plan_id: str
    plan_name: str
    strategy: Literal['foldover', 'd_optimal', 'custom']
    strategy_config: Union[FoldoverConfig, OptimalAugmentConfig]
    
    # Design context
    original_design: pd.DataFrame
    factors: Any  # List[Factor] - avoiding circular import
    
    # Expected outcomes
    n_runs_to_add: int
    total_runs_after: int
    expected_improvements: Dict[str, str]
    
    # Benefits
    benefits_responses: List[str]
    primary_beneficiary: str
    
    # Cost-benefit
    experimental_cost: float
    utility_score: float
    rank: int
    
    # Additional context
    metadata: Dict[str, Any] = field(default_factory=dict)
    
    def validate(self) -> ValidationResult:
        """
        Validate plan before execution.
        
        Returns
        -------
        ValidationResult
            Validation result with errors/warnings
        """
        errors = []
        warnings = []
        metrics = {}
        
        # Check: sufficient runs
        if self.n_runs_to_add < 1:
            errors.append("Must add at least 1 run")
        
        # Check: factors defined
        if not self.factors:
            errors.append("No factors defined")
        
        # Check: original design not empty
        if self.original_design is None or len(self.original_design) == 0:
            errors.append("Original design is empty")
        
        # Check: strategy-specific validation
        if self.strategy == 'foldover':
            config = self.strategy_config
            if config.foldover_type == 'single_factor':
                if not config.factor_to_fold:
                    errors.append("Single-factor foldover requires factor_to_fold")
                else:
                    factor_names = [f.name for f in self.factors]
                    if config.factor_to_fold not in factor_names:
                        errors.append(
                            f"Factor '{config.factor_to_fold}' not in design"
                        )
        
        elif self.strategy == 'd_optimal':
            config = self.strategy_config
            if not config.new_model_terms:
                errors.append("D-optimal augmentation requires new_model_terms")
        
        # Warnings
        if self.n_runs_to_add > len(self.original_design):
            warnings.append(
                f"Adding {self.n_runs_to_add} runs to {len(self.original_design)} "
                "run design - augmentation is larger than original"
            )
        
        is_valid = len(errors) == 0
        
        return ValidationResult(
            is_valid=is_valid,
            errors=errors,
            warnings=warnings,
            metrics=metrics
        )
    
    def execute(self) -> 'AugmentedDesign':
        """
        Execute this augmentation plan.
        
        This delegates to strategy-specific execution functions.
        
        Returns
        -------
        AugmentedDesign
            Result of augmentation
        
        Raises
        ------
        ValueError
            If plan is invalid
        RuntimeError
            If execution fails
        """
        # Validate first
        validation = self.validate()
        if not validation.is_valid:
            raise ValueError(
                f"Plan validation failed: {', '.join(validation.errors)}"
            )
        
        # Delegate to strategy-specific execution
        if self.strategy == 'foldover':
            from src.core.augmentation.foldover import execute_foldover_plan
            return execute_foldover_plan(self)
        
        elif self.strategy == 'd_optimal':
            from src.core.augmentation.optimal import execute_optimal_plan
            return execute_optimal_plan(self)
        
        else:
            raise ValueError(f"Unknown strategy: {self.strategy}")
    
    def to_dict(self) -> dict:
        """
        Convert plan to dictionary for serialization.
        
        Returns
        -------
        dict
            Plan as dictionary
        """
        return {
            'plan_id': self.plan_id,
            'plan_name': self.plan_name,
            'strategy': self.strategy,
            'n_runs_to_add': self.n_runs_to_add,
            'total_runs_after': self.total_runs_after,
            'expected_improvements': self.expected_improvements,
            'benefits_responses': self.benefits_responses,
            'primary_beneficiary': self.primary_beneficiary,
            'experimental_cost': self.experimental_cost,
            'utility_score': self.utility_score,
            'rank': self.rank
        }


@dataclass
class AugmentedDesign:
    """
    Result of executing an augmentation plan.
    
    Attributes
    ----------
    combined_design : pd.DataFrame
        Original + new runs with 'Phase' column
    new_runs_only : pd.DataFrame
        Just the new runs (for download)
    block_column : str
        Name of column indicating phases ('Phase')
    n_runs_original : int
        Number of runs in original design
    n_runs_added : int
        Number of runs added
    n_runs_total : int
        Total runs (original + added)
    achieved_improvements : Dict[str, str]
        Actual improvements (may differ from expected)
    resolution : int, optional
        New resolution (for fractional designs)
    d_efficiency : float, optional
        D-efficiency (for optimal designs)
    condition_number : float
        Condition number of model matrix
    updated_alias_structure : Dict[str, List[str]], optional
        New alias structure (for fractional)
    is_valid : bool
        Whether augmented design passes validation
    validation_warnings : List[str]
        Validation warnings
    plan_executed : AugmentationPlan
        Plan that generated this design
    
    Examples
    --------
    >>> augmented = plan.execute()
    >>> print(f"Added {augmented.n_runs_added} runs")
    >>> print(f"Resolution improved to {augmented.resolution}")
    >>> augmented.combined_design.to_csv('augmented_design.csv')
    """
    combined_design: pd.DataFrame
    new_runs_only: pd.DataFrame
    
    # Structure
    block_column: str
    n_runs_original: int
    n_runs_added: int
    n_runs_total: int
    
    # Quality metrics
    achieved_improvements: Dict[str, str]
    resolution: Optional[int] = None
    d_efficiency: Optional[float] = None
    condition_number: float = np.inf
    
    # Design-specific info
    updated_alias_structure: Optional[Dict[str, List[str]]] = None
    
    # Validation
    is_valid: bool = True
    validation_warnings: List[str] = field(default_factory=list)
    
    # Provenance
    plan_executed: Optional[AugmentationPlan] = None
    
    def summary(self) -> str:
        """
        Generate human-readable summary.
        
        Returns
        -------
        str
            Summary text
        """
        lines = []
        lines.append(f"Augmented Design Summary")
        lines.append(f"  Original runs: {self.n_runs_original}")
        lines.append(f"  Runs added: {self.n_runs_added}")
        lines.append(f"  Total runs: {self.n_runs_total}")
        lines.append(f"")
        lines.append(f"Improvements:")
        for metric, improvement in self.achieved_improvements.items():
            lines.append(f"  {metric}: {improvement}")
        
        if self.validation_warnings:
            lines.append(f"")
            lines.append(f"Warnings:")
            for warning in self.validation_warnings:
                lines.append(f"  - {warning}")
        
        return "\n".join(lines)
    
    def validate(self) -> ValidationResult:
        """
        Validate augmented design.
        
        Returns
        -------
        ValidationResult
            Validation result
        """
        errors = []
        warnings = []
        metrics = {}
        
        # Check: correct number of runs
        expected_total = self.n_runs_original + self.n_runs_added
        actual_total = len(self.combined_design)
        
        if actual_total != expected_total:
            errors.append(
                f"Run count mismatch: expected {expected_total}, got {actual_total}"
            )
        
        # Check: block column exists
        if self.block_column not in self.combined_design.columns:
            errors.append(f"Block column '{self.block_column}' not found")
        
        # Check: no duplicate runs
        factor_cols = [c for c in self.combined_design.columns 
                      if c not in ['StdOrder', 'RunOrder', self.block_column, 'Phase']]
        
        if len(factor_cols) > 0:
            duplicates = self.combined_design[factor_cols].duplicated().sum()
            if duplicates > 0:
                warnings.append(f"Found {duplicates} duplicate run(s)")
        
        # Check: condition number
        if self.condition_number > 100:
            warnings.append(
                f"High condition number ({self.condition_number:.1f}) "
                "- design may be ill-conditioned"
            )
        
        is_valid = len(errors) == 0
        
        return ValidationResult(
            is_valid=is_valid,
            errors=errors,
            warnings=warnings,
            metrics=metrics
        )